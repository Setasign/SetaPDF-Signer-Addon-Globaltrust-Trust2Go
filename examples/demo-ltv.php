<?php

declare(strict_types=1);

use GuzzleHttp\Client as GuzzleClient;
use GuzzleHttp\Handler\CurlHandler;
use Http\Factory\Guzzle\RequestFactory;
use Http\Factory\Guzzle\StreamFactory;
use setasign\SetaPDF\Signer\Module\GlobalTrustTrust2Go\Client;
use setasign\SetaPDF\Signer\Module\GlobalTrustTrust2Go\Module;
use setasign\SetaPDF2\Core\Document;
use setasign\SetaPDF2\Core\Reader\FileReader;
use setasign\SetaPDF2\Core\Writer\FileWriter;
use setasign\SetaPDF2\Core\Writer\TempFileWriter;
use setasign\SetaPDF2\Signer\Digest;
use setasign\SetaPDF2\Signer\DocumentSecurityStore;
use setasign\SetaPDF2\Signer\PemHelper;
use setasign\SetaPDF2\Signer\Signer;
use setasign\SetaPDF2\Signer\Timestamp\Module\Rfc3161\Curl as CurlTsModule;
use setasign\SetaPDF2\Signer\ValidationRelatedInfo\Collector;
use setasign\SetaPDF2\Signer\X509\Certificate;
use setasign\SetaPDF2\Signer\X509\Collection;

require_once __DIR__ . '/../vendor/autoload.php';

if (!file_exists(__DIR__ . '/settings.php')) {
    throw new RuntimeException('Missing settings.php!');
}
$settings = require __DIR__ . '/settings.php';

$file = __DIR__ . '/assets/lenstown/Laboratory-Report.pdf';
$certificateSerialNumber = $settings['certificateSerialNumber'];
// A requestID generated by the client to identify this signature operation (6 alphanumeric characters)
$requestId = '123456';

$caBundle = realpath(__DIR__ . '/assets/globaltrust-all.pem');

$httpClient = new GuzzleClient([
    'handler' => new CurlHandler(),
    // note: guzzle requires this parameter to fully support PSR-18
    'http_errors' => false,
    // timeout by api after ~300 seconds
    'timeout' => 360,
]);

$client = new Client(
    $httpClient,
    new RequestFactory(),
    new StreamFactory(),
    $settings['apiUrl'],
    $settings['username'],
    $settings['activationPin']
);
// This information should be cached
$certificates = $client->getCertificateBySerialNumber($certificateSerialNumber);
$certificate = new Certificate($certificates['certificate']);

$module = new Module($client, $requestId, $certificateSerialNumber);
$module->setCertificate($certificate);
$module->setExtraCertificates($certificates['chain']);
$module->setDigest(Digest::SHA_512);

$reader = new FileReader($file);
$writer = new FileWriter(__DIR__ . '/output/demo-ltv.pdf');
$tmpWriter = new TempFileWriter();
// let's get the document
$document = Document::load($reader, $tmpWriter);

// now let's create a signer instance
$signer = new Signer($document);
$signer->setAllowSignatureContentLengthChange(false);
$signer->setSignatureContentLength(26000);

if ($settings['tsUrl']) {
    $tsModule = new CurlTsModule($settings['tsUrl']);
    $tsModule->setCurlOption(CURLOPT_USERPWD, $settings['tsUsername'] . ':' . $settings['tsPassword']);
    if (isset($settings['tsCaBundle'])) {
        $tsModule->setCurlOption(CURLOPT_CAINFO, $settings['tsCaBundle']);
    }
    $signer->setTimestampModule($tsModule);
}

// set some signature properties
$signer->setReason('Testing TRUST2GO');

$field = $signer->getSignatureField();
$fieldName = $field->getQualifiedName();
$signer->setSignatureFieldName($fieldName);

$signer->sign($module);

$document = Document::loadByFilename($tmpWriter->getPath(), $writer);

// Create a collection of trusted certificats:
$trustedCertificates = new Collection($certificates['chain']);
$trustedCertificates->add(PemHelper::extractFromFile($caBundle));

// Create a collector instance
$collector = new Collector($trustedCertificates);

// Collect revocation information for this field
$vriData = $collector->getByFieldName($document, $fieldName);

// Debug process for resolving verification related information
//foreach ($collector->getLogger()->getLogs() as $log) {
//    echo str_repeat(' ', $log->getDepth() * 4) . $log . "\n";
//}

$dss = new DocumentSecurityStore($document);
$dss->addValidationRelatedInfoByFieldName(
    $fieldName,
    $vriData->getCrls(),
    $vriData->getOcspResponses(),
    $vriData->getCertificates()
);

$document->save()->finish();
