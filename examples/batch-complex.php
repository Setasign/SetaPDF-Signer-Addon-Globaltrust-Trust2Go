<?php

declare(strict_types=1);

use Ramsey\Uuid\Uuid;
use setasign\SetaPDF\Signer\Module\GlobalTrustTrust2Go\Batch;
use setasign\SetaPDF\Signer\Module\GlobalTrustTrust2Go\Client;
use GuzzleHttp\Client as GuzzleClient;
use GuzzleHttp\Handler\CurlHandler;
use Http\Factory\Guzzle\RequestFactory;
use Http\Factory\Guzzle\StreamFactory;
use setasign\SetaPDF2\Core\Document;
use setasign\SetaPDF2\Core\Font\Type0\Subset as Type0Subset;
use setasign\SetaPDF2\Core\Reader\FileReader;
use setasign\SetaPDF2\Core\Reader\StringReader;
use setasign\SetaPDF2\Core\Writer\FileInterface as FileWriterInterface;
use setasign\SetaPDF2\Core\Writer\FileWriter;
use setasign\SetaPDF2\Signer\Signature\Appearance\Dynamic as DynamicAppearance;
use setasign\SetaPDF2\Signer\Signature\Module\Pades;
use setasign\SetaPDF2\Signer\SignatureField;
use setasign\SetaPDF2\Signer\Signer;
use setasign\SetaPDF2\Signer\Timestamp\Module\Rfc3161\Curl as CurlTsModule;
use setasign\SetaPDF2\Signer\ValidationRelatedInfo\Exception as ValidationRelatedInfoException;

require_once __DIR__ . '/../vendor/autoload.php';

if (!file_exists(__DIR__ . '/settings.php')) {
    throw new RuntimeException('Missing settings.php!');
}
$settings = require __DIR__ . '/settings.php';

$file = __DIR__ . '/assets/tektown/Laboratory-Report.pdf';
$certificateSerialNumber = $settings['certificateSerialNumber'];
// A requestID generated by the client to identify this signature operation (6 alphanumeric characters)
$requestId = '123456';

$caBundle = \realpath(__DIR__ . '/assets/globaltrust-all.pem');

$httpClient = new GuzzleClient([
    'handler' => new CurlHandler(),
    // note: guzzle requires this parameter to fully support PSR-18
    'http_errors' => false,
    // timeout by api after ~300 seconds
    'timeout' => 360,
]);

$client = new Client(
    $httpClient,
    new RequestFactory(),
    new StreamFactory(),
    $settings['apiUrl'],
    $settings['username'],
    $settings['activationPin']
);

$batch = new Batch($client, $requestId, $certificateSerialNumber);
$batch->getTrustedCertificates()
    ->add(SetaPDF_Signer_Pem::extractFromFile($caBundle));

// create a re-usable array of filenames (in/out)
$files = [
    [
        'in' => new FileReader('assets/tektown/Laboratory-Report.pdf'),
        'out' => 'output/tektown-signed.pdf'
    ],
    [
        'in' => new StringReader(file_get_contents('assets/lenstown/Laboratory-Report.pdf')),
        'out' => 'output/lenstown-signed.pdf'
    ],
    [
        'in' => 'assets/etown/Laboratory-Report.pdf',
        'out' => 'output/etown-signed.pdf'
    ],
    [
        'in' => 'assets/camtown/Laboratory-Report.pdf',
        'out' => 'output/camtown-signed.pdf'
    ],
];

/* This callback has to create/get and return the field instance that should be used for the signature.
 * It is also possible to add signature properties or create a field appearance in this callback.
 */
$callback = static function(
    $key,
    array $file,
    Signer $signer,
    Pades $padesModule,
    Document $document
): SignatureField {
    // set some signature properties
    $signer->setReason('Signature for document ' . basename($file['out']));
    $signer->setLocation('Test Environment');

    $appearance = new DynamicAppearance($padesModule);
//    // let's create a font instance to not use standard fonts (not embedded)
//    $font = new Type0Subset(
//        $document,
//        'assets/fonts/DejaVu/ttf/DejaVuSans.ttf'
//    );
//    // and pass it to the appearance module
//    $appearance->setFont($font);
    $signer->setAppearance($appearance);

    return $signer->addSignatureField(
        SignatureField::DEFAULT_FIELD_NAME,
        1,
        SignatureField::POSITION_LEFT_TOP,
        [
            'x' => 20,
            'y' => -20
        ],
        200,
        50
    );
};

/* If you need control over the temporary file which needs to be created during the signature process, you can
 * create another callback, that has to return a writer instance for this file.
 * NOTE: You need to clean up these files on your own!
 */
//$tempFileCallback = static function($key, $file): FileWriterInterface {
//    return new FileWriter('output/tmp-' . $key);
//};

// If you want to add timestamps to the signautre you can pass an appropriate module like this:
if ($settings['tsUrl']) {
    $timestampModule = new CurlTsModule($settings['tsUrl']);
    $timestampModule->setCurlOption(CURLOPT_USERPWD, $settings['tsUsername'] . ':' . $settings['tsPassword']);
    if (isset($settings['tsCaBundle'])) {
        $timestampModule->setCurlOption(CURLOPT_CAINFO, $settings['tsCaBundle']);
    }
    $batch->setTimestampModule($timestampModule);
}

try {
    $batch->sign($files, true, $callback/*, $tempFileCallback*/);

} catch (ValidationRelatedInfoException $e) {
    // If VRI (validation related information) cannot be resolved, let's check the logs:
    foreach ($batch->getVriLoggers() as $key => $logger) {
        foreach ($logger->getLogs() as $log) {
            echo str_repeat(' ', $log->getDepth() * 4);
            echo $log->getMessage() . "\n";
        }
    }
}
